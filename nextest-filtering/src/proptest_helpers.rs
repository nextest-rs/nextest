// Copyright (c) The nextest Contributors
// SPDX-License-Identifier: MIT OR Apache-2.0

use crate::{
    parsing::{Expr, SetDef},
    NameMatcher,
};
use guppy::graph::cargo::BuildPlatform;
use proptest::prelude::*;

impl Expr<()> {
    #[doc(hidden)]
    pub fn strategy() -> impl Strategy<Value = Self> {
        let leaf = SetDef::strategy().prop_map(Self::Set);

        leaf.prop_recursive(8, 256, 10, |inner| {
            prop_oneof![
                1 => inner.clone().prop_map(|a| Self::Not(Box::new(a))),
                1 => (inner.clone(), inner.clone()).prop_map(|(a, b)| Self::Union(Box::new(a), Box::new(b))),
                1 => (inner.clone(), inner).prop_map(|(a, b)| Self::Intersection(Box::new(a), Box::new(b))),
            ]
        })
    }
}

impl SetDef<()> {
    pub(crate) fn strategy() -> impl Strategy<Value = Self> {
        prop_oneof![
            1 => NameMatcher::strategy().prop_map(|s| Self::Package(s, ())),
            1 => NameMatcher::strategy().prop_map(|s| Self::Deps(s, ())),
            1 => NameMatcher::strategy().prop_map(|s| Self::Rdeps(s, ())),
            1 => NameMatcher::strategy().prop_map(|s| Self::Kind(s, ())),
            1 => NameMatcher::strategy().prop_map(|s| Self::Binary(s, ())),
            1 => build_platform_strategy().prop_map(|p| Self::Platform(p, ())),
            1 => NameMatcher::strategy().prop_map(|s| Self::Test(s, ())),
            1 => Just(Self::All),
            1 => Just(Self::None),
        ]
    }
}

impl NameMatcher {
    pub(crate) fn strategy() -> impl Strategy<Value = Self> {
        prop_oneof![
            1 => name_strategy().prop_map(Self::Equal),
            1 => name_strategy().prop_map(Self::Contains),
            1 => regex_strategy().prop_map(Self::Regex),
        ]
    }
}

pub(crate) fn build_platform_strategy() -> impl Strategy<Value = BuildPlatform> {
    prop::sample::select(&[BuildPlatform::Host, BuildPlatform::Target][..])
}

pub(crate) fn name_strategy() -> impl Strategy<Value = String> {
    prop_oneof![
        4 => "[abcde]{0,10}",
        // Some escapes
        1 => r"[abcde=/~]{0,10}",
        // More escapes
        1 => r"[abcde=/~\r\t\n\u{2055}\u{1fe4e}]{0,10}",
    ]
}

pub(crate) fn regex_strategy() -> impl Strategy<Value = regex::Regex> {
    regex_str_strategy().prop_map(|s| {
        regex::Regex::new(&s).expect("all regexes generated by the strategy are valid")
    })
}

fn regex_str_strategy() -> impl Strategy<Value = String> {
    // TODO: add more cases here
    let leaf = prop_oneof![
        4 => "[abcde]{0,10}",
        // Some escapes
        1 => r"([abcde]|(\\\?)|(\\\*)|){0,10}",
        // More escapes
        1 => r"[abcde/\r\t\n\u{2055}\u{1fe4e}]{0,10}",
    ];

    // TODO: add more recursion cases here
    leaf.prop_recursive(
        // Up to 3 levels deep
        3,
        // Max size 16 nodes
        16,
        // Up to 3 items per collection
        3,
        |inner| {
            prop_oneof![
                1 => (inner.clone(), inner.clone()).prop_map(|(a, b)| {
                    format!("{a}{b}")
                }),
                1 => (inner.clone(), inner.clone()).prop_map(|(a, b)| {
                    format!("({a})|({b})")
                }),
                1 => inner.clone().prop_map(|a| {
                    format!("({a})*")
                }),
                1 => inner.prop_map(|a| {
                    format!("({a})?")
                }),
            ]
        },
    )
}

// > instance Arbitrary (RegExp Char) where
// >   arbitrary = sized regexp
// >
// > regexp :: Int -> Gen (RegExp Char)
// > regexp 0 = frequency [ (1, return eps)
// >                      , (4, char `fmap` simpleChar) ]
// > regexp n = frequency [ (3, regexp 0)
// >                      , (1, alt  `fmap` subexp `ap` subexp)
// >                      , (2, seq_ `fmap` subexp `ap` subexp)
// >                      , (1, rep  `fmap` regexp (n-1))
// >                      , (2, fromString `fmap` parsedRegExp n) ]
// >  where subexp = regexp (n `div` 2)
// >
// > simpleChar :: Gen Char
// > simpleChar = elements "abcde"
// >
// > parsedRegExp :: Int -> Gen String
// > parsedRegExp n = frequency [ (4, symClass)
// >                            , (2, (++"?") `fmap` subexp)
// >                            , (2, (++"+") `fmap` subexp)
// >                            , (1, mkBrep1 =<< subexp)
// >                            , (1, mkBrep2 =<< subexp) ]
// >  where
// >   subexp = (($"") . showParen True . shows)
// >     `fmap` (resize (n-1) arbitrary :: Gen (RegExp Char))
// >
// >   mkBrep1 r = do x <- elements [0..3] :: Gen Int
// >                  return $ r ++ "{" ++ show x ++ "}"
// >
// >   mkBrep2 r = do x <- elements [0..2] :: Gen Int
// >                  y <- elements [0..2] :: Gen Int
// >                  return $ r ++ "{" ++ show x ++ "," ++ show (x+y) ++ "}"
// >
// > symClass :: Gen String
// > symClass = frequency [ (1, specialChar)
// >                      , (2, do n <- choose (0,3)
// >                               cs <- replicateM n charClass
// >                               s <- (["","^"]!!) `fmap` choose (0,1)
// >                               return $ "[" ++ s ++ concat cs ++ "]") ]
// >  where
// >   specialChar = elements (map (:[]) "." ++
// >                           map (\c -> '\\':[c]) "abcdewWdDsS \\|*+?.[]{}^")
// >   charClass   = oneof [ (:[]) `fmap` simpleChar
// >                       , specialChar
// >                       , do x <- simpleChar
// >                            y <- simpleChar
// >                            return $ x : '-' : [chr (ord x+ord y-ord 'a')] ]

#[cfg(test)]
mod tests {
    use super::*;

    #[test_strategy::proptest]
    fn proptest_regex_valid(#[strategy(regex_str_strategy())] regex_str: String) {
        println!("regex_str = {regex_str:?}");
        regex::Regex::new(&regex_str).expect("all regexes generated by the strategy are valid");
    }
}
